import binary_encode
import binary_decode

def test_packet_format():
    print("--- Testing Packet Formatting ---")
    
    # 1. Construct a mock AX.25 frame using BinaryEncoder
    # Source: N0CALL-0, Dest: APZ001, Path: WIDE1-1, Payload: >Hello World
    encoder = binary_encode.BinaryEncoder()
    callsign = "N0CALL"
    ssid = 0
    # Destination is usually APxxxx for APRS software version, or just generic APRS
    # construct_ax25_frame(self, my_call, my_ssid=0, dest="APRS", dest_ssid=0, payload="")
    payload = "!3248.20N/11709.09W>Test Packet"
    raw_ax25 = encoder.construct_ax25_frame(callsign, ssid, dest="APZ001", payload=payload)
    
    print(f"Constructed Raw AX.25 (Hex): {raw_ax25.hex()}")
    
    # 2. Decode it using BinaryDecoder (mocking what comes from TNC)
    decoder = binary_decode.BinaryDecoder()
    
    # We need to simulate the full KISS frame [FEND, 0x00, AX25..., FEND] for the decoder?
    # No, decode_frame takes the full frame INCLUDING FENDs according to comments.
    kiss_frame = b'\xc0\x00' + raw_ax25 + b'\xc0'
    
    decoded = decoder.decode_frame(kiss_frame)
    if not decoded:
        print("Failed to decode frame!")
        return

    print("Decoded Dictionary:", decoded)

    # 3. Convert to TNC2 (APRS-IS format)
    # Source>Dest,Path:Payload
    # The to_tnc2 method signature: to_tnc2(self, parsed_data, callsign_s)
    # callsign_s is the IGate's callsign, which is appended to the path as qAR,IGATECALL
    igate_call = "IGATE-10"
    tnc2_line = decoder.to_tnc2(decoded, igate_call)
    
    print(f"\nGeneratred TNC2 Line: '{tnc2_line}'")
    
    # 4. Verify Format
    # Expected: SOURCE>DEST,PATH,qAR,IGATE:PAYLOAD
    # We need to check binary_encode defaults to know DEST/PATH
    
    if tnc2_line.endswith("\r\n"):
        print("WARNING: TNC2 line generated by decoder has CR/LF. APRS-IS wrapper usually adds this.")
    else:
        print("OK: TNC2 line has no trailing CR/LF (Wrapper should add it).")
        
    parts = tnc2_line.split(':')
    header = parts[0]
    body = ':'.join(parts[1:])
    
    print(f"Header: {header}")
    print(f"Body:   {body}")
    
    if ">" in header and "," in header:
        print("SUCCESS: Header looks correct (Source>Dest,Path).")
    else:
        print("FAILURE: Header malformed.")

if __name__ == "__main__":
    test_packet_format()
